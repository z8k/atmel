//////////////////////////////////////////////////////////////////////////////
//                                                                           /
// IAR Atmel AVR C/EC++ Compiler V3.20A/W32            19/Aug/2004  16:08:03 /
// Copyright 1996-2004 IAR Systems. All rights reserved.                     /
//                                                                           /
//    Source file  =  Z:\qvcs\AVR318 Dallas 1-wire Communication             /
//                    Interface\Source Code\IAR\polled\main.c                /
//    Command line =  --cpu=m32 -ms -o "Z:\qvcs\AVR318 Dallas 1-wire         /
//                    Communication Interface\Source                         /
//                    Code\IAR\polled\Debug\Obj\" -lC "Z:\qvcs\AVR318        /
//                    Dallas 1-wire Communication Interface\Source           /
//                    Code\IAR\polled\Debug\List\" -lA "Z:\qvcs\AVR318       /
//                    Dallas 1-wire Communication Interface\Source           /
//                    Code\IAR\polled\Debug\List\" --initializers_in_flash   /
//                    --root_variables -z2 --no_cse --no_inline              /
//                    --no_code_motion --no_cross_call --no_clustering       /
//                    --debug -DENABLE_BIT_DEFINITIONS -e -I "C:\Program     /
//                    Files\IAR Systems\Embedded Workbench 3.2\avr\INC\" -I  /
//                    "C:\Program Files\IAR Systems\Embedded Workbench       /
//                    3.2\avr\INC\CLIB\" --eeprom_size 1024 "Z:\qvcs\AVR318  /
//                    Dallas 1-wire Communication Interface\Source           /
//                    Code\IAR\polled\main.c"                                /
//    List file    =  Z:\qvcs\AVR318 Dallas 1-wire Communication             /
//                    Interface\Source Code\IAR\polled\Debug\List\main.s90   /
//                                                                           /
//                                                                           /
//////////////////////////////////////////////////////////////////////////////

        NAME main

        RTMODEL "__64bit_doubles", "disabled"
        RTMODEL "__cpu", "3"
        RTMODEL "__cpu_name", "ATmega32"
        RTMODEL "__enhanced_core", "enabled"
        RTMODEL "__has_elpm", "false"
        RTMODEL "__memory_model", "2"
        RTMODEL "__rt_version", "3"

        RSEG CSTACK:DATA:NOROOT(0)
        RSEG RSTACK:DATA:NOROOT(0)

        EXTERN ?EPILOGUE_B15_L09
        EXTERN ?EPILOGUE_B4_L09
        EXTERN ?EPILOGUE_B6_L09
        EXTERN ?PROLOGUE15_L09
        EXTERN ?PROLOGUE4_L09
        EXTERN ?PROLOGUE6_L09
        EXTERN ?PROLOGUE7_L09
        EXTERN ?Register_R10_is_cg_reg
        EXTERN ?Register_R11_is_cg_reg
        EXTERN ?Register_R12_is_cg_reg
        EXTERN ?Register_R13_is_cg_reg
        EXTERN ?Register_R14_is_cg_reg
        EXTERN ?Register_R4_is_cg_reg
        EXTERN ?Register_R5_is_cg_reg
        EXTERN ?Register_R6_is_cg_reg
        EXTERN ?Register_R7_is_cg_reg
        EXTERN ?Register_R8_is_cg_reg
        EXTERN ?Register_R9_is_cg_reg
        EXTERN ?S_EC_MUL_L02
        EXTERN ?need_segment_init

        PUBWEAK `?<Segment init: NEAR_Z>`
        PUBLIC DS1820_ReadTemperature
        FUNCTION DS1820_ReadTemperature,021203H
        LOCFRAME CSTACK, 6, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC DS2890_SetWiperPosition
        FUNCTION DS2890_SetWiperPosition,021203H
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC FindFamily
        FUNCTION FindFamily,0203H
        LOCFRAME RSTACK, 2, STACK
        PUBLIC SearchBuses
        FUNCTION SearchBuses,021203H
        LOCFRAME CSTACK, 15, STACK
        LOCFRAME RSTACK, 4, STACK
        PUBWEAK _A_ACSR
        PUBWEAK _A_ADC
        PUBWEAK _A_ADCSRA
        PUBWEAK _A_ADMUX
        PUBWEAK _A_ASSR
        PUBWEAK _A_DDRA
        PUBWEAK _A_DDRB
        PUBWEAK _A_DDRC
        PUBWEAK _A_DDRD
        PUBWEAK _A_EEAR
        PUBWEAK _A_EECR
        PUBWEAK _A_EEDR
        PUBWEAK _A_GICR
        PUBWEAK _A_GIFR
        PUBWEAK _A_ICR1
        PUBWEAK _A_MCUCR
        PUBWEAK _A_MCUCSR
        PUBWEAK _A_OCR0
        PUBWEAK _A_OCR1A
        PUBWEAK _A_OCR1B
        PUBWEAK _A_OCR2
        PUBWEAK _A_OSCCAL
        PUBWEAK _A_PINA
        PUBWEAK _A_PINB
        PUBWEAK _A_PINC
        PUBWEAK _A_PIND
        PUBWEAK _A_PORTA
        PUBWEAK _A_PORTB
        PUBWEAK _A_PORTC
        PUBWEAK _A_PORTD
        PUBWEAK _A_SFIOR
        PUBWEAK _A_SP
        PUBWEAK _A_SPCR
        PUBWEAK _A_SPDR
        PUBWEAK _A_SPMCR
        PUBWEAK _A_SPSR
        PUBWEAK _A_SREG
        PUBWEAK _A_TCCR0
        PUBWEAK _A_TCCR1A
        PUBWEAK _A_TCCR1B
        PUBWEAK _A_TCCR2
        PUBWEAK _A_TCNT0
        PUBWEAK _A_TCNT1
        PUBWEAK _A_TCNT2
        PUBWEAK _A_TIFR
        PUBWEAK _A_TIMSK
        PUBWEAK _A_TWAR
        PUBWEAK _A_TWBR
        PUBWEAK _A_TWCR
        PUBWEAK _A_TWDR
        PUBWEAK _A_TWSR
        PUBWEAK _A_UBRRH
        PUBWEAK _A_UBRRL
        PUBWEAK _A_UCSRA
        PUBWEAK _A_UCSRB
        PUBWEAK _A_UDR
        PUBWEAK _A_WDTCR
        PUBWEAK __?EEARH
        PUBWEAK __?EEARL
        PUBWEAK __?EECR
        PUBWEAK __?EEDR
        PUBLIC main
        FUNCTION main,021a03H
        LOCFRAME CSTACK, 7, STACK
        LOCFRAME RSTACK, 2, STACK
        
        CFI Names cfiNames0
        CFI StackFrame CFA_Y Y DATA
        CFI StackFrame CFA_SP SP DATA
        CFI VirtualResource ?RetPad:1, ?RetHigh:8, ?RetLow:8, ?Ret:17
        CFI Resource R0:8, R1:8, R2:8, R3:8, R4:8, R5:8, R6:8, R7:8, R8:8, R9:8
        CFI Resource R10:8, R11:8, R12:8, R13:8, R14:8, R15:8, R16:8, R17:8
        CFI Resource R18:8, R19:8, R20:8, R21:8, R22:8, R23:8, R24:8, R25:8
        CFI Resource R26:8, R27:8, R28:8, R29:8, R30:8, R31:8
        CFI Resource ?RetHighByteMask:8, SP:16, SPH:8, SPL:8, Y:16
        CFI ResourceParts ?Ret ?RetHigh, ?RetLow, ?RetPad
        CFI ResourceParts SP SPH, SPL
        CFI ResourceParts Y R29, R28
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 1
        CFI DataAlign 1
        CFI ReturnAddress ?Ret CODE
        CFI CFA_Y Y+0
        CFI CFA_SP SP+2
        CFI ?RetPad 0
        CFI ?RetHigh and(load(1, DATA, sub(CFA_SP, 1)), ?RetHighByteMask)
        CFI ?RetLow Frame(CFA_SP, 0)
        CFI ?Ret Concat
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 SameValue
        CFI R13 SameValue
        CFI R14 SameValue
        CFI R15 SameValue
        CFI R16 Undefined
        CFI R17 Undefined
        CFI R18 Undefined
        CFI R19 Undefined
        CFI R20 Undefined
        CFI R21 Undefined
        CFI R22 Undefined
        CFI R23 Undefined
        CFI R24 SameValue
        CFI R25 SameValue
        CFI R26 SameValue
        CFI R27 SameValue
        CFI R28 Undefined
        CFI R29 Undefined
        CFI R30 Undefined
        CFI R31 Undefined
        CFI ?RetHighByteMask SameValue
        CFI SPH Undefined
        CFI SPL Undefined
        CFI EndCommon cfiCommon0
        
        EXTERN OWI_Init
        FUNCTION OWI_Init,0202H
        EXTERN OWI_DetectPresence
        FUNCTION OWI_DetectPresence,0202H
        EXTERN memcpy
        FUNCTION memcpy,010202H
        EXTERN OWI_SearchRom
        FUNCTION OWI_SearchRom,0202H
        EXTERN OWI_CheckRomCRC
        FUNCTION OWI_CheckRomCRC,0202H
        EXTERN OWI_MatchRom
        FUNCTION OWI_MatchRom,0202H
        EXTERN OWI_SendByte
        FUNCTION OWI_SendByte,0202H
        EXTERN OWI_ReadBit
        FUNCTION OWI_ReadBit,0202H
        EXTERN OWI_ReceiveByte
        FUNCTION OWI_ReceiveByte,0202H

// Z:\qvcs\AVR318 Dallas 1-wire Communication Interface\Source Code\IAR\polled\main.c
//    1 // This file has been prepared for Doxygen automatic documentation generation.
//    2 /*! \file ********************************************************************
//    3 *
//    4 * Atmel Corporation
//    5 *
//    6 * \li File:               main.c
//    7 * \li Compiler:           IAR EWAAVR 3.20a
//    8 * \li Support mail:       avr@atmel.com
//    9 *
//   10 * \li Supported devices:  All AVRs.
//   11 *
//   12 * \li Application Note:   AVR318 - Dallas 1-Wire(R) master.
//   13 *                         
//   14 *
//   15 * \li Description:        Example on how to use the 1-Wire(R) interface
//   16 *                         master.
//   17 *
//   18 *                         $Revision: 1.6 $
//   19 *                         $Date: Thursday, August 19, 2004 09:02:02 UTC $
//   20 ****************************************************************************/
//   21 
//   22 #include <ioavr.h>
//   23 #include <inavr.h>
//   24 
//   25 #include "OWIPolled.h"
//   26 #include "OWIHighLevelFunctions.h"
//   27 #include "OWIBitFunctions.h"
//   28 #include "..\common_files\OWIcrc.h"
//   29 
//   30 #include <string.h> // Used for memcpy.
//   31 
//   32 
//   33 // Defines used only in code example.
//   34 #define DS1820_FAMILY_ID                0x10 
//   35 #define DS1820_START_CONVERSION         0x44
//   36 #define DS1820_READ_SCRATCHPAD          0xbe
//   37 #define DS1820_ERROR                    -1000   // Return code. Outside temperature range.
//   38 
//   39 #define DS2890_FAMILY_ID                0x2c
//   40 #define DS2890_WRITE_CONTROL_REGISTER   0X55
//   41 #define DS2890_RELEASE_CODE             0x96
//   42 #define DS2890_WRITE_POSITION           0x0f
//   43 
//   44 #define SEARCH_SUCCESSFUL               0x00
//   45 #define SEARCH_CRC_ERROR                0x01
//   46 
//   47 #define FALSE       0
//   48 #define TRUE        1
//   49 
//   50 #define MAX_DEVICES 8       //!< Max number of devices to search for.
//   51 
//   52 #define BUSES   (OWI_PIN_0 | OWI_PIN_1) //!< Buses to search.
//   53 
//   54 
//   55 /*! \brief  Data type used to hold information about slave devices.
//   56  *  
//   57  *  The OWI_device data type holds information about what bus each device
//   58  *  is connected to, and its 64 bit identifier.
//   59  */
//   60 typedef struct
//   61 {
//   62     unsigned char bus;      //!< A bitmask of the bus the device is connected to.
//   63     unsigned char id[8];    //!< The 64 bit identifier.
//   64 } OWI_device;
//   65 
//   66 
//   67 // Prototypes of functions used in exemples.
//   68 unsigned char SearchBuses(OWI_device * devices, unsigned char len, unsigned char buses);
//   69 OWI_device * FindFamily(unsigned char familyID, OWI_device * devices, unsigned char size);
//   70 signed int DS1820_ReadTemperature(unsigned char bus, unsigned char * id);
//   71 void DS2890_SetWiperPosition(unsigned char position, unsigned char bus, unsigned char * id);
//   72 
//   73 
//   74 /*! \brief  Example application for the polled drivers.
//   75  *
//   76  *  Example application for the software only and polled UART driver.
//   77  *  This example application will find all devices (upper bounded by MAX_DEVICES) 
//   78  *  on the buses defined by BUSES. It then tries to find either a DS1820 or DS2890 
//   79  *  device on a bus, and communicate with them to read temperature (DS1820) or 
//   80  *  set wiper position (DS2890).
//   81  *  This example is not written in a very optimal way. It is merely intended to show
//   82  *  how the polled 1-Wire(R) driver can be used.
//   83  */

        RSEG CODE:CODE:NOROOT(1)
//   84 void main(void)
main:
        CFI Block cfiBlock0 Using cfiCommon0
        CFI Function main
//   85 {
        FUNCALL main, OWI_Init
        LOCFRAME CSTACK, 7, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL main, SearchBuses
        LOCFRAME CSTACK, 7, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL main, FindFamily
        LOCFRAME CSTACK, 7, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL main, FindFamily
        LOCFRAME CSTACK, 7, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL main, DS1820_ReadTemperature
        LOCFRAME CSTACK, 7, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL main, DS2890_SetWiperPosition
        LOCFRAME CSTACK, 7, STACK
        LOCFRAME RSTACK, 2, STACK
	CALL	?PROLOGUE7_L09
        CFI R6 Frame(CFA_Y, -1)
        CFI R5 Frame(CFA_Y, -2)
        CFI R4 Frame(CFA_Y, -3)
        CFI R27 Frame(CFA_Y, -4)
        CFI R26 Frame(CFA_Y, -5)
        CFI R25 Frame(CFA_Y, -6)
        CFI R24 Frame(CFA_Y, -7)
        CFI CFA_Y Y+7
	REQUIRE	?Register_R4_is_cg_reg
	REQUIRE	?Register_R5_is_cg_reg
	REQUIRE	?Register_R6_is_cg_reg
//   86     static OWI_device devices[MAX_DEVICES];
//   87     OWI_device * ds1820;
//   88     OWI_device * ds2890;
//   89     signed int temperature = 0;
	CLR	R4
	CLR	R5
//   90     unsigned char wiperPos = 0;
	CLR	R6
//   91     
//   92     // Initialize PORTB as output. Can be used to display values on
//   93     // the LEDs on a STK500 development board.
//   94     DDRB = 0xff;
	LDI	R16,255
	OUT	0x17,R16
//   95 
//   96     OWI_Init(BUSES);
	LDI	R16,3
	CALL	OWI_Init
//   97     
//   98     // Do the bus search until all ids are read without crc error.    
//   99     while(SearchBuses(devices, MAX_DEVICES, BUSES) != SEARCH_SUCCESSFUL)
??main_0:
	LDI	R19,3
	LDI	R18,8
	LDI	R16,LOW(??devices)
	LDI	R17,(??devices) >> 8
	RCALL	SearchBuses
	TST	R16
	BRNE	??main_0
//  100     {
//  101     
//  102     }
//  103     
//  104     // See if there is a DS1820 or DS2890 on a bus.
//  105     ds1820 = FindFamily(DS1820_FAMILY_ID, devices, MAX_DEVICES);
	LDI	R17,8
	LDI	R18,LOW(??devices)
	LDI	R19,(??devices) >> 8
	LDI	R16,16
	RCALL	FindFamily
	MOVW	R25 : R24,R17 : R16
//  106     ds2890 = FindFamily(DS2890_FAMILY_ID, devices, MAX_DEVICES);
	LDI	R17,8
	LDI	R18,LOW(??devices)
	LDI	R19,(??devices) >> 8
	LDI	R16,44
	RCALL	FindFamily
	MOVW	R27 : R26,R17 : R16
//  107     
//  108     // Do something useful with the slave devices in an eternal loop.
//  109     for (;;)
//  110     {
//  111         // If there is a DS1820 temperature sensor on a bus, read the
//  112         // temperature.
//  113         // The DS1820 must have Vdd pin connected for this code to work.
//  114         if (ds1820 != NULL)
??main_1:
	MOV	R16,R24
	OR	R16,R25
	BREQ	??main_2
//  115         {
//  116             temperature = DS1820_ReadTemperature((*ds1820).bus, (*ds1820).id);
	MOVW	R19 : R18,R25 : R24
	SUBI	R18,255
	SBCI	R19,255
	MOVW	R31 : R30,R25 : R24
	LD	R16,Z
	RCALL	DS1820_ReadTemperature
	MOVW	R5 : R4,R17 : R16
//  117         }        
//  118         // If there is a DS2890 digital potentiometer, increment the
//  119         // wiper value.
//  120         if (ds2890 != NULL)
??main_2:
	MOV	R16,R26
	OR	R16,R27
	BREQ	??main_3
//  121         {
//  122             DS2890_SetWiperPosition(wiperPos++, (*ds2890).bus, (*ds2890).id);
	MOVW	R19 : R18,R27 : R26
	SUBI	R18,255
	SBCI	R19,255
	LD	R17,X
	MOV	R16,R6
	RCALL	DS2890_SetWiperPosition
	INC	R6
//  123         }
//  124         
//  125         // Discard lsb of temperature and output to PORTB.
//  126         PORTB = ~(temperature >> 1);
??main_3:
	MOVW	R17 : R16,R5 : R4
	ASR	R17
	ROR	R16
	COM	R16
	OUT	0x18,R16
	RJMP	??main_1
        CFI EndBlock cfiBlock0
//  127     }
//  128 }

        RSEG NEAR_Z:DATA:ROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
??devices:
        DS 72
//  129 
//  130 
//  131 /*! \brief  Perform a 1-Wire search
//  132  *
//  133  *  This function shows how the OWI_SearchRom function can be used to 
//  134  *  discover all slaves on the bus. It will also CRC check the 64 bit
//  135  *  identifiers.
//  136  *
//  137  *  \param  devices Pointer to an array of type OWI_device. The discovered 
//  138  *                  devices will be placed from the beginning of this array.
//  139  *
//  140  *  \param  len     The length of the device array. (Max. number of elements).
//  141  *
//  142  *  \param  buses   Bitmask of the buses to perform search on.
//  143  *
//  144  *  \retval SEARCH_SUCCESSFUL   Search completed successfully.
//  145  *  \retval SEARCH_CRC_ERROR    A CRC error occured. Probably because of noise
//  146  *                              during transmission.
//  147  */

        RSEG CODE:CODE:NOROOT(1)
//  148 unsigned char SearchBuses(OWI_device * devices, unsigned char len, unsigned char buses)
SearchBuses:
        CFI Block cfiBlock1 Using cfiCommon0
        CFI Function SearchBuses
//  149 {
        FUNCALL SearchBuses, OWI_DetectPresence
        LOCFRAME CSTACK, 15, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL SearchBuses, memcpy
        LOCFRAME CSTACK, 15, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL SearchBuses, OWI_DetectPresence
        LOCFRAME CSTACK, 15, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL SearchBuses, OWI_SearchRom
        LOCFRAME CSTACK, 15, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL SearchBuses, OWI_CheckRomCRC
        LOCFRAME CSTACK, 15, STACK
        LOCFRAME RSTACK, 2, STACK
	CALL	?PROLOGUE15_L09
        CFI R14 Frame(CFA_Y, -1)
        CFI R13 Frame(CFA_Y, -2)
        CFI R12 Frame(CFA_Y, -3)
        CFI R11 Frame(CFA_Y, -4)
        CFI R10 Frame(CFA_Y, -5)
        CFI R9 Frame(CFA_Y, -6)
        CFI R8 Frame(CFA_Y, -7)
        CFI R7 Frame(CFA_Y, -8)
        CFI R6 Frame(CFA_Y, -9)
        CFI R5 Frame(CFA_Y, -10)
        CFI R4 Frame(CFA_Y, -11)
        CFI R27 Frame(CFA_Y, -12)
        CFI R26 Frame(CFA_Y, -13)
        CFI R25 Frame(CFA_Y, -14)
        CFI R24 Frame(CFA_Y, -15)
        CFI CFA_Y Y+15
	REQUIRE	?Register_R4_is_cg_reg
	REQUIRE	?Register_R5_is_cg_reg
	REQUIRE	?Register_R6_is_cg_reg
	REQUIRE	?Register_R7_is_cg_reg
	REQUIRE	?Register_R8_is_cg_reg
	REQUIRE	?Register_R9_is_cg_reg
	REQUIRE	?Register_R10_is_cg_reg
	REQUIRE	?Register_R11_is_cg_reg
	REQUIRE	?Register_R12_is_cg_reg
	REQUIRE	?Register_R13_is_cg_reg
	REQUIRE	?Register_R14_is_cg_reg
	MOVW	R25 : R24,R17 : R16
	MOV	R13,R18
//  150     unsigned char i, j;
//  151     unsigned char presence;
//  152     unsigned char * newID;
//  153     unsigned char * currentID;
//  154     unsigned char currentBus;
//  155     unsigned char lastDeviation;
//  156     unsigned char numDevices;
//  157     
//  158     // Initialize all addresses as zero, on bus 0 (does not exist).
//  159     // Do a search on the bus to discover all addresses.    
//  160     for (i = 0; i < len; i++)
	LDI	R27,0
??SearchBuses_0:
	CP	R27,R13
	BRCC	??SearchBuses_1
//  161     {
//  162         devices[i].bus = 0x00;
	LDI	R16,0
	MOV	R9,R16
	MOV	R20,R27
	LDI	R21,0
	LDI	R16,9
	LDI	R17,0
	CALL	?S_EC_MUL_L02
	MOVW	R31 : R30,R25 : R24
	ADD	R30,R16
	ADC	R31,R17
	ST	Z,R9
//  163         for (j = 0; j < 8; j++)
	CLR	R6
??SearchBuses_2:
	LDI	R16,8
	CP	R6,R16
	BRCC	??SearchBuses_3
//  164         {
//  165             devices[i].id[j] = 0x00;
	LDI	R16,0
	MOV	R9,R16
	MOV	R20,R27
	LDI	R21,0
	LDI	R16,9
	LDI	R17,0
	CALL	?S_EC_MUL_L02
	MOVW	R31 : R30,R25 : R24
	ADD	R30,R16
	ADC	R31,R17
	MOV	R16,R6
	LDI	R17,0
	ADD	R30,R16
	ADC	R31,R17
	STD	Z+1,R9
//  166         }
	INC	R6
	RJMP	??SearchBuses_2
//  167     }
??SearchBuses_3:
	INC	R27
	RJMP	??SearchBuses_0
//  168     
//  169     // Find the buses with slave devices.
//  170     presence = OWI_DetectPresence(BUSES);
??SearchBuses_1:
	LDI	R16,3
	CALL	OWI_DetectPresence
	MOV	R12,R16
//  171     
//  172     numDevices = 0;
	CLR	R7
//  173     newID = devices[0].id;
	MOVW	R17 : R16,R25 : R24
	SUBI	R16,255
	SBCI	R17,255
	MOVW	R5 : R4,R17 : R16
//  174     
//  175     // Go through all buses with slave devices.
//  176     for (currentBus = 0x01; currentBus; currentBus <<= 1)
	LDI	R26,1
??SearchBuses_4:
	TST	R26
	BREQ	??SearchBuses_5
//  177     {
//  178         lastDeviation = 0;
	CLR	R8
//  179         currentID = newID;
	MOVW	R11 : R10,R5 : R4
//  180         if (currentBus & presence) // Devices available on this bus.
	MOV	R16,R12
	AND	R16,R26
	TST	R16
	BREQ	??SearchBuses_6
//  181         {
//  182             // Do slave search on each bus, and place identifiers and corresponding
//  183             // bus "addresses" in the array.
//  184             do  
//  185             {
//  186                 memcpy(newID, currentID, 8);
??SearchBuses_7:
	LDI	R20,8
	LDI	R21,0
	MOVW	R19 : R18,R11 : R10
	MOVW	R17 : R16,R5 : R4
	CALL	memcpy
//  187                 OWI_DetectPresence(currentBus);
	MOV	R16,R26
	CALL	OWI_DetectPresence
//  188                 lastDeviation = OWI_SearchRom(newID, lastDeviation, currentBus);
	MOV	R19,R26
	MOV	R18,R8
	MOVW	R17 : R16,R5 : R4
	CALL	OWI_SearchRom
	MOV	R8,R16
//  189                 currentID = newID;
	MOVW	R11 : R10,R5 : R4
//  190                 devices[numDevices].bus = currentBus;
	MOV	R20,R7
	LDI	R21,0
	LDI	R16,9
	LDI	R17,0
	CALL	?S_EC_MUL_L02
	MOVW	R31 : R30,R25 : R24
	ADD	R30,R16
	ADC	R31,R17
	ST	Z,R26
//  191                 numDevices++;
	INC	R7
//  192                 newID=devices[numDevices].id;                
	MOV	R20,R7
	LDI	R21,0
	LDI	R16,9
	LDI	R17,0
	CALL	?S_EC_MUL_L02
	MOVW	R19 : R18,R25 : R24
	ADD	R18,R16
	ADC	R19,R17
	SUBI	R18,255
	SBCI	R19,255
	MOVW	R5 : R4,R19 : R18
//  193             }  while(lastDeviation != OWI_ROM_SEARCH_FINISHED);            
	TST	R8
	BRNE	??SearchBuses_7
//  194         }
//  195     }
??SearchBuses_6:
	LSL	R26
	RJMP	??SearchBuses_4
//  196 
//  197     // Go through all the devices and do CRC check.
//  198     for (i = 0; i < numDevices; i++)
??SearchBuses_5:
	LDI	R27,0
??SearchBuses_8:
	CP	R27,R7
	BRCC	??SearchBuses_9
//  199     {
//  200         // If any id has a crc error, return error.
//  201         if(OWI_CheckRomCRC(devices[i].id) != OWI_CRC_OK)
	MOV	R20,R27
	LDI	R21,0
	LDI	R16,9
	LDI	R17,0
	CALL	?S_EC_MUL_L02
	MOVW	R19 : R18,R25 : R24
	ADD	R18,R16
	ADC	R19,R17
	SUBI	R18,255
	SBCI	R19,255
	MOVW	R17 : R16,R19 : R18
	CALL	OWI_CheckRomCRC
	TST	R16
	BREQ	??SearchBuses_10
//  202         {
//  203             return SEARCH_CRC_ERROR;
	LDI	R16,1
	RJMP	??SearchBuses_11
//  204         }
//  205     }
??SearchBuses_10:
	INC	R27
	RJMP	??SearchBuses_8
//  206     // Else, return Successful.
//  207     return SEARCH_SUCCESSFUL;
??SearchBuses_9:
	LDI	R16,0
??SearchBuses_11:
	LDI	R30,15
	JMP	?EPILOGUE_B15_L09
        CFI EndBlock cfiBlock1
//  208 }
//  209 
//  210 /*! \brief  Find the first device of a family based on the family id
//  211  *
//  212  *  This function returns a pointer to a device in the device array
//  213  *  that matches the specified family.
//  214  *
//  215  *  \param  familyID    The 8 bit family ID to search for.
//  216  *
//  217  *  \param  devices     An array of devices to search through.
//  218  *
//  219  *  \param  size        The size of the array 'devices'
//  220  *
//  221  *  \return A pointer to a device of the family.
//  222  *  \retval NULL    if no device of the family was found.
//  223  */

        RSEG CODE:CODE:NOROOT(1)
//  224 OWI_device * FindFamily(unsigned char familyID, OWI_device * devices, unsigned char size)
FindFamily:
        CFI Block cfiBlock2 Using cfiCommon0
        CFI Function FindFamily
//  225 {
	MOV	R20,R16
	MOV	R22,R17
//  226     unsigned char i = 0;
	LDI	R21,0
//  227     
//  228     // Search through the array.
//  229     while (i < size)
??FindFamily_0:
	CP	R21,R22
	BRCC	??FindFamily_1
//  230     {
//  231         // Return the pointer if there is a family id match.
//  232         if ((*devices).id[0] == familyID)
	MOVW	R31 : R30,R19 : R18
	LDD	R16,Z+1
	CP	R16,R20
	BRNE	??FindFamily_2
//  233         {
//  234             return devices;
	MOVW	R17 : R16,R19 : R18
	RET
//  235         }
//  236         devices++;
??FindFamily_2:
	SUBI	R18,247
	SBCI	R19,255
//  237         i++;
	INC	R21
	RJMP	??FindFamily_0
//  238     }
//  239     // Else, return NULL.
//  240     return NULL;
??FindFamily_1:
	LDI	R16,0
	LDI	R17,0
	RET
        CFI EndBlock cfiBlock2
//  241 }
//  242 
//  243 
//  244 /*! \brief  Read the temperature from a DS1820 temperature sensor.
//  245  *
//  246  *  This function will start a conversion and read back the temperature
//  247  *  from a DS1820 temperature sensor.
//  248  *
//  249  *  \param  bus A bitmask of the bus where the DS1820 is located.
//  250  *  
//  251  *  \param  id  The 64 bit identifier of the DS1820.
//  252  *
//  253  *  \return The 16 bit signed temperature read from the DS1820.
//  254  */

        RSEG CODE:CODE:NOROOT(1)
//  255 signed int DS1820_ReadTemperature(unsigned char bus, unsigned char * id)
DS1820_ReadTemperature:
        CFI Block cfiBlock3 Using cfiCommon0
        CFI Function DS1820_ReadTemperature
//  256 {
        FUNCALL DS1820_ReadTemperature, OWI_DetectPresence
        LOCFRAME CSTACK, 6, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL DS1820_ReadTemperature, OWI_MatchRom
        LOCFRAME CSTACK, 6, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL DS1820_ReadTemperature, OWI_SendByte
        LOCFRAME CSTACK, 6, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL DS1820_ReadTemperature, OWI_ReadBit
        LOCFRAME CSTACK, 6, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL DS1820_ReadTemperature, OWI_DetectPresence
        LOCFRAME CSTACK, 6, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL DS1820_ReadTemperature, OWI_MatchRom
        LOCFRAME CSTACK, 6, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL DS1820_ReadTemperature, OWI_SendByte
        LOCFRAME CSTACK, 6, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL DS1820_ReadTemperature, OWI_ReceiveByte
        LOCFRAME CSTACK, 6, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL DS1820_ReadTemperature, OWI_ReceiveByte
        LOCFRAME CSTACK, 6, STACK
        LOCFRAME RSTACK, 2, STACK
	CALL	?PROLOGUE6_L09
        CFI R5 Frame(CFA_Y, -1)
        CFI R4 Frame(CFA_Y, -2)
        CFI R27 Frame(CFA_Y, -3)
        CFI R26 Frame(CFA_Y, -4)
        CFI R25 Frame(CFA_Y, -5)
        CFI R24 Frame(CFA_Y, -6)
        CFI CFA_Y Y+6
	REQUIRE	?Register_R4_is_cg_reg
	REQUIRE	?Register_R5_is_cg_reg
	MOV	R24,R16
	MOVW	R27 : R26,R19 : R18
//  257     signed int temperature;
//  258     
//  259     // Reset, presence.
//  260     if (!OWI_DetectPresence(bus))
	MOV	R16,R24
	CALL	OWI_DetectPresence
	TST	R16
	BRNE	??DS1820_ReadTemperature_0
//  261     {
//  262         return DS1820_ERROR; // Error
	LDI	R16,24
	LDI	R17,252
	RJMP	??DS1820_ReadTemperature_1
//  263     }
//  264     // Match the id found earlier.
//  265     OWI_MatchRom(id, bus);
??DS1820_ReadTemperature_0:
	MOV	R18,R24
	MOVW	R17 : R16,R27 : R26
	CALL	OWI_MatchRom
//  266     // Send start conversion command.
//  267     OWI_SendByte(DS1820_START_CONVERSION, bus);
	MOV	R17,R24
	LDI	R16,68
	CALL	OWI_SendByte
//  268     // Wait until conversion is finished.
//  269     // Bus line is held low until conversion is finished.
//  270     while (!OWI_ReadBit(bus))
??DS1820_ReadTemperature_2:
	MOV	R16,R24
	CALL	OWI_ReadBit
	TST	R16
	BREQ	??DS1820_ReadTemperature_2
//  271     {
//  272     
//  273     }
//  274     // Reset, presence.
//  275     if(!OWI_DetectPresence(bus))
	MOV	R16,R24
	CALL	OWI_DetectPresence
	TST	R16
	BRNE	??DS1820_ReadTemperature_3
//  276     {
//  277         return -1000; // Error
	LDI	R16,24
	LDI	R17,252
	RJMP	??DS1820_ReadTemperature_1
//  278     }
//  279     // Match id again.
//  280     OWI_MatchRom(id, bus);
??DS1820_ReadTemperature_3:
	MOV	R18,R24
	MOVW	R17 : R16,R27 : R26
	CALL	OWI_MatchRom
//  281     // Send READ SCRATCHPAD command.
//  282     OWI_SendByte(DS1820_READ_SCRATCHPAD, bus);
	MOV	R17,R24
	LDI	R16,190
	CALL	OWI_SendByte
//  283     // Read only two first bytes (temperature low, temperature high)
//  284     // and place them in the 16 bit temperature variable.
//  285     temperature = OWI_ReceiveByte(bus);
	MOV	R16,R24
	CALL	OWI_ReceiveByte
	LDI	R17,0
	MOVW	R5 : R4,R17 : R16
//  286     temperature |= (OWI_ReceiveByte(bus) << 8);
	MOV	R16,R24
	CALL	OWI_ReceiveByte
	MOV	R19,R16
	LDI	R18,0
	OR	R4,R18
	OR	R5,R19
//  287     
//  288     return temperature;
	MOVW	R17 : R16,R5 : R4
??DS1820_ReadTemperature_1:
	LDI	R30,6
	JMP	?EPILOGUE_B6_L09
        CFI EndBlock cfiBlock3
//  289 }
//  290 
//  291 
//  292 /*! \brief  Set the wiper position of a DS2890.
//  293  *
//  294  *  This function initializes the DS2890 by enabling the charge pump. It then
//  295  *  changes the wiper position.
//  296  *
//  297  *  \param  position    The new wiper position.
//  298  *
//  299  *  \param  bus         The bus where the DS2890 is connected.
//  300  *
//  301  *  \param  id          The 64 bit identifier of the DS2890.
//  302  */

        RSEG CODE:CODE:NOROOT(1)
//  303 void DS2890_SetWiperPosition(unsigned char position, unsigned char bus, unsigned char * id)
DS2890_SetWiperPosition:
        CFI Block cfiBlock4 Using cfiCommon0
        CFI Function DS2890_SetWiperPosition
//  304 {
        FUNCALL DS2890_SetWiperPosition, OWI_DetectPresence
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL DS2890_SetWiperPosition, OWI_MatchRom
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL DS2890_SetWiperPosition, OWI_SendByte
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL DS2890_SetWiperPosition, OWI_SendByte
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL DS2890_SetWiperPosition, OWI_ReceiveByte
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL DS2890_SetWiperPosition, OWI_SendByte
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL DS2890_SetWiperPosition, OWI_ReceiveByte
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL DS2890_SetWiperPosition, OWI_DetectPresence
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL DS2890_SetWiperPosition, OWI_MatchRom
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL DS2890_SetWiperPosition, OWI_SendByte
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL DS2890_SetWiperPosition, OWI_SendByte
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL DS2890_SetWiperPosition, OWI_ReceiveByte
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL DS2890_SetWiperPosition, OWI_SendByte
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL DS2890_SetWiperPosition, OWI_ReceiveByte
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
	CALL	?PROLOGUE4_L09
        CFI R27 Frame(CFA_Y, -1)
        CFI R26 Frame(CFA_Y, -2)
        CFI R25 Frame(CFA_Y, -3)
        CFI R24 Frame(CFA_Y, -4)
        CFI CFA_Y Y+4
	MOV	R25,R16
	MOV	R24,R17
	MOVW	R27 : R26,R19 : R18
//  305     // Reset, presence.
//  306     if(!OWI_DetectPresence(bus))
	MOV	R16,R24
	CALL	OWI_DetectPresence
	TST	R16
	BREQ	??DS2890_SetWiperPosition_0
//  307     {
//  308         return;
//  309     }
//  310     //Match id.
//  311     OWI_MatchRom(id, bus);
	MOV	R18,R24
	MOVW	R17 : R16,R27 : R26
	CALL	OWI_MatchRom
//  312     
//  313     // Send Write control register command.
//  314     OWI_SendByte(DS2890_WRITE_CONTROL_REGISTER, bus);
	MOV	R17,R24
	LDI	R16,85
	CALL	OWI_SendByte
//  315     
//  316     // Write 0x4c to control register to enable charge pump.
//  317     OWI_SendByte(0x4c, bus);
	MOV	R17,R24
	LDI	R16,76
	CALL	OWI_SendByte
//  318     
//  319     // Check that the value returned matches the value sent.
//  320     if (OWI_ReceiveByte(bus) != 0x4c)
	MOV	R16,R24
	CALL	OWI_ReceiveByte
	CPI	R16,76
	BRNE	??DS2890_SetWiperPosition_0
//  321     {
//  322         return;
//  323     }
//  324     
//  325     // Send release code to update control register.
//  326     OWI_SendByte(DS2890_RELEASE_CODE, bus);
	MOV	R17,R24
	LDI	R16,150
	CALL	OWI_SendByte
//  327     
//  328     // Check that zeros are returned to ensure that the operation was
//  329     // successful.
//  330     if (OWI_ReceiveByte(bus) == 0xff)
	MOV	R16,R24
	CALL	OWI_ReceiveByte
	CPI	R16,255
	BREQ	??DS2890_SetWiperPosition_0
//  331     {
//  332         return;
//  333     }
//  334     
//  335     // Reset, presence.
//  336     if (!OWI_DetectPresence(bus))
	MOV	R16,R24
	CALL	OWI_DetectPresence
	TST	R16
	BREQ	??DS2890_SetWiperPosition_0
//  337     {
//  338         return;
//  339     }
//  340     
//  341     // Match id.
//  342     OWI_MatchRom(id, bus);
	MOV	R18,R24
	MOVW	R17 : R16,R27 : R26
	CALL	OWI_MatchRom
//  343     
//  344     // Send the Write Position command.
//  345     OWI_SendByte(DS2890_WRITE_POSITION, bus);
	MOV	R17,R24
	LDI	R16,15
	CALL	OWI_SendByte
//  346     
//  347     // Send the new position.
//  348     OWI_SendByte(position, bus);
	MOV	R17,R24
	MOV	R16,R25
	CALL	OWI_SendByte
//  349     
//  350     // Check that the value returned matches the value sent.
//  351     if (OWI_ReceiveByte(bus) != position)
	MOV	R16,R24
	CALL	OWI_ReceiveByte
	CP	R16,R25
	BRNE	??DS2890_SetWiperPosition_0
//  352     {
//  353         return;
//  354     }
//  355     
//  356     // Send release code to update wiper position.
//  357     OWI_SendByte(DS2890_RELEASE_CODE, bus);
	MOV	R17,R24
	LDI	R16,150
	CALL	OWI_SendByte
//  358     
//  359     // Check that zeros are returned to ensure that the operation was
//  360     // successful.
//  361     if (OWI_ReceiveByte(bus) == 0xff)
	MOV	R16,R24
	CALL	OWI_ReceiveByte
??DS2890_SetWiperPosition_0:
	LDI	R30,4
	JMP	?EPILOGUE_B4_L09
        CFI EndBlock cfiBlock4
//  362     {   
//  363         return;
//  364     }
//  365 }

        RSEG INITTAB:CODE:NOROOT(0)
`?<Segment init: NEAR_Z>`:
	DW	SFE(NEAR_Z) - SFB(NEAR_Z)
	DW	SFB(NEAR_Z)
	DW	0
	REQUIRE ?need_segment_init

        ASEGN ABSOLUTE:DATA:ROOT,03eH
// union <unnamed> volatile __io _A_EEAR
_A_EEAR:
        DS 2

        ASEGN ABSOLUTE:DATA:ROOT,040H
// union <unnamed> volatile __io _A_UBRRH
_A_UBRRH:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,041H
// union <unnamed> volatile __io _A_WDTCR
_A_WDTCR:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,042H
// union <unnamed> volatile __io _A_ASSR
_A_ASSR:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,043H
// union <unnamed> volatile __io _A_OCR2
_A_OCR2:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,044H
// union <unnamed> volatile __io _A_TCNT2
_A_TCNT2:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,045H
// union <unnamed> volatile __io _A_TCCR2
_A_TCCR2:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,046H
// union <unnamed> volatile __io _A_ICR1
_A_ICR1:
        DS 2

        ASEGN ABSOLUTE:DATA:ROOT,048H
// union <unnamed> volatile __io _A_OCR1B
_A_OCR1B:
        DS 2

        ASEGN ABSOLUTE:DATA:ROOT,04aH
// union <unnamed> volatile __io _A_OCR1A
_A_OCR1A:
        DS 2

        ASEGN ABSOLUTE:DATA:ROOT,04cH
// union <unnamed> volatile __io _A_TCNT1
_A_TCNT1:
        DS 2

        ASEGN ABSOLUTE:DATA:ROOT,04eH
// union <unnamed> volatile __io _A_TCCR1B
_A_TCCR1B:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,04fH
// union <unnamed> volatile __io _A_TCCR1A
_A_TCCR1A:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,050H
// union <unnamed> volatile __io _A_SFIOR
_A_SFIOR:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,051H
// union <unnamed> volatile __io _A_OSCCAL
_A_OSCCAL:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,052H
// union <unnamed> volatile __io _A_TCNT0
_A_TCNT0:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,053H
// union <unnamed> volatile __io _A_TCCR0
_A_TCCR0:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,054H
// union <unnamed> volatile __io _A_MCUCSR
_A_MCUCSR:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,055H
// union <unnamed> volatile __io _A_MCUCR
_A_MCUCR:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,056H
// union <unnamed> volatile __io _A_TWCR
_A_TWCR:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,057H
// union <unnamed> volatile __io _A_SPMCR
_A_SPMCR:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,058H
// union <unnamed> volatile __io _A_TIFR
_A_TIFR:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,059H
// union <unnamed> volatile __io _A_TIMSK
_A_TIMSK:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,05aH
// union <unnamed> volatile __io _A_GIFR
_A_GIFR:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,05bH
// union <unnamed> volatile __io _A_GICR
_A_GICR:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,05cH
// union <unnamed> volatile __io _A_OCR0
_A_OCR0:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,05dH
// union <unnamed> volatile __io _A_SP
_A_SP:
        DS 2

        ASEGN ABSOLUTE:DATA:ROOT,05fH
// union <unnamed> volatile __io _A_SREG
_A_SREG:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,020H
// union <unnamed> volatile __io _A_TWBR
_A_TWBR:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,021H
// union <unnamed> volatile __io _A_TWSR
_A_TWSR:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,022H
// union <unnamed> volatile __io _A_TWAR
_A_TWAR:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,023H
// union <unnamed> volatile __io _A_TWDR
_A_TWDR:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,024H
// union <unnamed> volatile __io _A_ADC
_A_ADC:
        DS 2

        ASEGN ABSOLUTE:DATA:ROOT,026H
// union <unnamed> volatile __io _A_ADCSRA
_A_ADCSRA:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,027H
// union <unnamed> volatile __io _A_ADMUX
_A_ADMUX:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,028H
// union <unnamed> volatile __io _A_ACSR
_A_ACSR:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,029H
// union <unnamed> volatile __io _A_UBRRL
_A_UBRRL:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,02aH
// union <unnamed> volatile __io _A_UCSRB
_A_UCSRB:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,02bH
// union <unnamed> volatile __io _A_UCSRA
_A_UCSRA:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,02cH
// union <unnamed> volatile __io _A_UDR
_A_UDR:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,02dH
// union <unnamed> volatile __io _A_SPCR
_A_SPCR:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,02eH
// union <unnamed> volatile __io _A_SPSR
_A_SPSR:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,02fH
// union <unnamed> volatile __io _A_SPDR
_A_SPDR:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,030H
// union <unnamed> volatile __io _A_PIND
_A_PIND:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,031H
// union <unnamed> volatile __io _A_DDRD
_A_DDRD:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,032H
// union <unnamed> volatile __io _A_PORTD
_A_PORTD:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,033H
// union <unnamed> volatile __io _A_PINC
_A_PINC:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,034H
// union <unnamed> volatile __io _A_DDRC
_A_DDRC:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,035H
// union <unnamed> volatile __io _A_PORTC
_A_PORTC:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,036H
// union <unnamed> volatile __io _A_PINB
_A_PINB:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,037H
// union <unnamed> volatile __io _A_DDRB
_A_DDRB:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,038H
// union <unnamed> volatile __io _A_PORTB
_A_PORTB:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,039H
// union <unnamed> volatile __io _A_PINA
_A_PINA:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,03aH
// union <unnamed> volatile __io _A_DDRA
_A_DDRA:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,03bH
// union <unnamed> volatile __io _A_PORTA
_A_PORTA:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,03cH
// union <unnamed> volatile __io _A_EECR
_A_EECR:
        DS 1

        ASEGN ABSOLUTE:DATA:ROOT,03dH
// union <unnamed> volatile __io _A_EEDR
_A_EEDR:
        DS 1

        ASEGN ABSOLUTE:DATA:NOROOT,01cH
__?EECR:

        ASEGN ABSOLUTE:DATA:NOROOT,01dH
__?EEDR:

        ASEGN ABSOLUTE:DATA:NOROOT,01eH
__?EEARL:

        ASEGN ABSOLUTE:DATA:NOROOT,01fH
__?EEARH:

        END
// 
//  64 bytes in segment ABSOLUTE
// 658 bytes in segment CODE
//   6 bytes in segment INITTAB
//  72 bytes in segment NEAR_Z
// 
// 658 bytes of CODE memory (+  6 bytes shared)
//  72 bytes of DATA memory (+ 64 bytes shared)
//
//Errors: none
//Warnings: none
