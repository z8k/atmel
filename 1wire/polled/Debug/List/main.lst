##############################################################################
#                                                                            #
# IAR Atmel AVR C/EC++ Compiler V3.20A/W32             19/Aug/2004  16:08:04 #
# Copyright 1996-2004 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Source file  =  Z:\qvcs\AVR318 Dallas 1-wire Communication              #
#                    Interface\Source Code\IAR\polled\main.c                 #
#    Command line =  --cpu=m32 -ms -o "Z:\qvcs\AVR318 Dallas 1-wire          #
#                    Communication Interface\Source                          #
#                    Code\IAR\polled\Debug\Obj\" -lC "Z:\qvcs\AVR318 Dallas  #
#                    1-wire Communication Interface\Source                   #
#                    Code\IAR\polled\Debug\List\" -lA "Z:\qvcs\AVR318        #
#                    Dallas 1-wire Communication Interface\Source            #
#                    Code\IAR\polled\Debug\List\" --initializers_in_flash    #
#                    --root_variables -z2 --no_cse --no_inline               #
#                    --no_code_motion --no_cross_call --no_clustering        #
#                    --debug -DENABLE_BIT_DEFINITIONS -e -I "C:\Program      #
#                    Files\IAR Systems\Embedded Workbench 3.2\avr\INC\" -I   #
#                    "C:\Program Files\IAR Systems\Embedded Workbench        #
#                    3.2\avr\INC\CLIB\" --eeprom_size 1024 "Z:\qvcs\AVR318   #
#                    Dallas 1-wire Communication Interface\Source            #
#                    Code\IAR\polled\main.c"                                 #
#    List file    =  Z:\qvcs\AVR318 Dallas 1-wire Communication              #
#                    Interface\Source Code\IAR\polled\Debug\List\main.lst    #
#    Object file  =  Z:\qvcs\AVR318 Dallas 1-wire Communication              #
#                    Interface\Source Code\IAR\polled\Debug\Obj\main.r90     #
#                                                                            #
#                                                                            #
##############################################################################

Z:\qvcs\AVR318 Dallas 1-wire Communication Interface\Source Code\IAR\polled\main.c
      1          // This file has been prepared for Doxygen automatic documentation generation.
      2          /*! \file ********************************************************************
      3          *
      4          * Atmel Corporation
      5          *
      6          * \li File:               main.c
      7          * \li Compiler:           IAR EWAAVR 3.20a
      8          * \li Support mail:       avr@atmel.com
      9          *
     10          * \li Supported devices:  All AVRs.
     11          *
     12          * \li Application Note:   AVR318 - Dallas 1-Wire(R) master.
     13          *                         
     14          *
     15          * \li Description:        Example on how to use the 1-Wire(R) interface
     16          *                         master.
     17          *
     18          *                         $Revision: 1.6 $
     19          *                         $Date: Thursday, August 19, 2004 09:02:02 UTC $
     20          ****************************************************************************/
     21          
     22          #include <ioavr.h>
     23          #include <inavr.h>
     24          
     25          #include "OWIPolled.h"
     26          #include "OWIHighLevelFunctions.h"
     27          #include "OWIBitFunctions.h"
     28          #include "..\common_files\OWIcrc.h"
     29          
     30          #include <string.h> // Used for memcpy.
     31          
     32          
     33          // Defines used only in code example.
     34          #define DS1820_FAMILY_ID                0x10 
     35          #define DS1820_START_CONVERSION         0x44
     36          #define DS1820_READ_SCRATCHPAD          0xbe
     37          #define DS1820_ERROR                    -1000   // Return code. Outside temperature range.
     38          
     39          #define DS2890_FAMILY_ID                0x2c
     40          #define DS2890_WRITE_CONTROL_REGISTER   0X55
     41          #define DS2890_RELEASE_CODE             0x96
     42          #define DS2890_WRITE_POSITION           0x0f
     43          
     44          #define SEARCH_SUCCESSFUL               0x00
     45          #define SEARCH_CRC_ERROR                0x01
     46          
     47          #define FALSE       0
     48          #define TRUE        1
     49          
     50          #define MAX_DEVICES 8       //!< Max number of devices to search for.
     51          
     52          #define BUSES   (OWI_PIN_0 | OWI_PIN_1) //!< Buses to search.
     53          
     54          
     55          /*! \brief  Data type used to hold information about slave devices.
     56           *  
     57           *  The OWI_device data type holds information about what bus each device
     58           *  is connected to, and its 64 bit identifier.
     59           */
     60          typedef struct
     61          {
     62              unsigned char bus;      //!< A bitmask of the bus the device is connected to.
     63              unsigned char id[8];    //!< The 64 bit identifier.
     64          } OWI_device;
     65          
     66          
     67          // Prototypes of functions used in exemples.
     68          unsigned char SearchBuses(OWI_device * devices, unsigned char len, unsigned char buses);
     69          OWI_device * FindFamily(unsigned char familyID, OWI_device * devices, unsigned char size);
     70          signed int DS1820_ReadTemperature(unsigned char bus, unsigned char * id);
     71          void DS2890_SetWiperPosition(unsigned char position, unsigned char bus, unsigned char * id);
     72          
     73          
     74          /*! \brief  Example application for the polled drivers.
     75           *
     76           *  Example application for the software only and polled UART driver.
     77           *  This example application will find all devices (upper bounded by MAX_DEVICES) 
     78           *  on the buses defined by BUSES. It then tries to find either a DS1820 or DS2890 
     79           *  device on a bus, and communicate with them to read temperature (DS1820) or 
     80           *  set wiper position (DS2890).
     81           *  This example is not written in a very optimal way. It is merely intended to show
     82           *  how the polled 1-Wire(R) driver can be used.
     83           */

   \                                 In segment CODE, align 2, keep-with-next
     84          void main(void)
   \                     main:
     85          {
   \   00000000   ........                   CALL    ?PROLOGUE7_L09
   \   00000004                              REQUIRE ?Register_R4_is_cg_reg
   \   00000004                              REQUIRE ?Register_R5_is_cg_reg
   \   00000004                              REQUIRE ?Register_R6_is_cg_reg
     86              static OWI_device devices[MAX_DEVICES];
     87              OWI_device * ds1820;
     88              OWI_device * ds2890;
     89              signed int temperature = 0;
   \   00000004   2444                       CLR     R4
   \   00000006   2455                       CLR     R5
     90              unsigned char wiperPos = 0;
   \   00000008   2466                       CLR     R6
     91              
     92              // Initialize PORTB as output. Can be used to display values on
     93              // the LEDs on a STK500 development board.
     94              DDRB = 0xff;
   \   0000000A   EF0F                       LDI     R16,255
   \   0000000C   BB07                       OUT     0x17,R16
     95          
     96              OWI_Init(BUSES);
   \   0000000E   E003                       LDI     R16,3
   \   00000010   ........                   CALL    OWI_Init
     97              
     98              // Do the bus search until all ids are read without crc error.    
     99              while(SearchBuses(devices, MAX_DEVICES, BUSES) != SEARCH_SUCCESSFUL)
   \                     ??main_0:
   \   00000014   E033                       LDI     R19,3
   \   00000016   E028                       LDI     R18,8
   \   00000018   ....                       LDI     R16,LOW(??devices)
   \   0000001A   ....                       LDI     R17,(??devices) >> 8
   \   0000001C   ....                       RCALL   SearchBuses
   \   0000001E   2300                       TST     R16
   \   00000020   F7C9                       BRNE    ??main_0
    100              {
    101              
    102              }
    103              
    104              // See if there is a DS1820 or DS2890 on a bus.
    105              ds1820 = FindFamily(DS1820_FAMILY_ID, devices, MAX_DEVICES);
   \   00000022   E018                       LDI     R17,8
   \   00000024   ....                       LDI     R18,LOW(??devices)
   \   00000026   ....                       LDI     R19,(??devices) >> 8
   \   00000028   E100                       LDI     R16,16
   \   0000002A   ....                       RCALL   FindFamily
   \   0000002C   01C8                       MOVW    R25 : R24,R17 : R16
    106              ds2890 = FindFamily(DS2890_FAMILY_ID, devices, MAX_DEVICES);
   \   0000002E   E018                       LDI     R17,8
   \   00000030   ....                       LDI     R18,LOW(??devices)
   \   00000032   ....                       LDI     R19,(??devices) >> 8
   \   00000034   E20C                       LDI     R16,44
   \   00000036   ....                       RCALL   FindFamily
   \   00000038   01D8                       MOVW    R27 : R26,R17 : R16
    107              
    108              // Do something useful with the slave devices in an eternal loop.
    109              for (;;)
    110              {
    111                  // If there is a DS1820 temperature sensor on a bus, read the
    112                  // temperature.
    113                  // The DS1820 must have Vdd pin connected for this code to work.
    114                  if (ds1820 != NULL)
   \                     ??main_1:
   \   0000003A   2F08                       MOV     R16,R24
   \   0000003C   2B09                       OR      R16,R25
   \   0000003E   F039                       BREQ    ??main_2
    115                  {
    116                      temperature = DS1820_ReadTemperature((*ds1820).bus, (*ds1820).id);
   \   00000040   019C                       MOVW    R19 : R18,R25 : R24
   \   00000042   5F2F                       SUBI    R18,255
   \   00000044   4F3F                       SBCI    R19,255
   \   00000046   01FC                       MOVW    R31 : R30,R25 : R24
   \   00000048   8100                       LD      R16,Z
   \   0000004A   ....                       RCALL   DS1820_ReadTemperature
   \   0000004C   0128                       MOVW    R5 : R4,R17 : R16
    117                  }        
    118                  // If there is a DS2890 digital potentiometer, increment the
    119                  // wiper value.
    120                  if (ds2890 != NULL)
   \                     ??main_2:
   \   0000004E   2F0A                       MOV     R16,R26
   \   00000050   2B0B                       OR      R16,R27
   \   00000052   F039                       BREQ    ??main_3
    121                  {
    122                      DS2890_SetWiperPosition(wiperPos++, (*ds2890).bus, (*ds2890).id);
   \   00000054   019D                       MOVW    R19 : R18,R27 : R26
   \   00000056   5F2F                       SUBI    R18,255
   \   00000058   4F3F                       SBCI    R19,255
   \   0000005A   911C                       LD      R17,X
   \   0000005C   2D06                       MOV     R16,R6
   \   0000005E   ....                       RCALL   DS2890_SetWiperPosition
   \   00000060   9463                       INC     R6
    123                  }
    124                  
    125                  // Discard lsb of temperature and output to PORTB.
    126                  PORTB = ~(temperature >> 1);
   \                     ??main_3:
   \   00000062   0182                       MOVW    R17 : R16,R5 : R4
   \   00000064   9515                       ASR     R17
   \   00000066   9507                       ROR     R16
   \   00000068   9500                       COM     R16
   \   0000006A   BB08                       OUT     0x18,R16
   \   0000006C   CFE6                       RJMP    ??main_1
    127              }
    128          }

   \                                 In segment NEAR_Z, align 1, keep-with-next, root
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \                     ??devices:
   \   00000000                              DS 72
    129          
    130          
    131          /*! \brief  Perform a 1-Wire search
    132           *
    133           *  This function shows how the OWI_SearchRom function can be used to 
    134           *  discover all slaves on the bus. It will also CRC check the 64 bit
    135           *  identifiers.
    136           *
    137           *  \param  devices Pointer to an array of type OWI_device. The discovered 
    138           *                  devices will be placed from the beginning of this array.
    139           *
    140           *  \param  len     The length of the device array. (Max. number of elements).
    141           *
    142           *  \param  buses   Bitmask of the buses to perform search on.
    143           *
    144           *  \retval SEARCH_SUCCESSFUL   Search completed successfully.
    145           *  \retval SEARCH_CRC_ERROR    A CRC error occured. Probably because of noise
    146           *                              during transmission.
    147           */

   \                                 In segment CODE, align 2, keep-with-next
    148          unsigned char SearchBuses(OWI_device * devices, unsigned char len, unsigned char buses)
   \                     SearchBuses:
    149          {
   \   00000000   ........                   CALL    ?PROLOGUE15_L09
   \   00000004                              REQUIRE ?Register_R4_is_cg_reg
   \   00000004                              REQUIRE ?Register_R5_is_cg_reg
   \   00000004                              REQUIRE ?Register_R6_is_cg_reg
   \   00000004                              REQUIRE ?Register_R7_is_cg_reg
   \   00000004                              REQUIRE ?Register_R8_is_cg_reg
   \   00000004                              REQUIRE ?Register_R9_is_cg_reg
   \   00000004                              REQUIRE ?Register_R10_is_cg_reg
   \   00000004                              REQUIRE ?Register_R11_is_cg_reg
   \   00000004                              REQUIRE ?Register_R12_is_cg_reg
   \   00000004                              REQUIRE ?Register_R13_is_cg_reg
   \   00000004                              REQUIRE ?Register_R14_is_cg_reg
   \   00000004   01C8                       MOVW    R25 : R24,R17 : R16
   \   00000006   2ED2                       MOV     R13,R18
    150              unsigned char i, j;
    151              unsigned char presence;
    152              unsigned char * newID;
    153              unsigned char * currentID;
    154              unsigned char currentBus;
    155              unsigned char lastDeviation;
    156              unsigned char numDevices;
    157              
    158              // Initialize all addresses as zero, on bus 0 (does not exist).
    159              // Do a search on the bus to discover all addresses.    
    160              for (i = 0; i < len; i++)
   \   00000008   E0B0                       LDI     R27,0
   \                     ??SearchBuses_0:
   \   0000000A   15BD                       CP      R27,R13
   \   0000000C   F520                       BRCC    ??SearchBuses_1
    161              {
    162                  devices[i].bus = 0x00;
   \   0000000E   E000                       LDI     R16,0
   \   00000010   2E90                       MOV     R9,R16
   \   00000012   2F4B                       MOV     R20,R27
   \   00000014   E050                       LDI     R21,0
   \   00000016   E009                       LDI     R16,9
   \   00000018   E010                       LDI     R17,0
   \   0000001A   ........                   CALL    ?S_EC_MUL_L02
   \   0000001E   01FC                       MOVW    R31 : R30,R25 : R24
   \   00000020   0FE0                       ADD     R30,R16
   \   00000022   1FF1                       ADC     R31,R17
   \   00000024   8290                       ST      Z,R9
    163                  for (j = 0; j < 8; j++)
   \   00000026   2466                       CLR     R6
   \                     ??SearchBuses_2:
   \   00000028   E008                       LDI     R16,8
   \   0000002A   1660                       CP      R6,R16
   \   0000002C   F490                       BRCC    ??SearchBuses_3
    164                  {
    165                      devices[i].id[j] = 0x00;
   \   0000002E   E000                       LDI     R16,0
   \   00000030   2E90                       MOV     R9,R16
   \   00000032   2F4B                       MOV     R20,R27
   \   00000034   E050                       LDI     R21,0
   \   00000036   E009                       LDI     R16,9
   \   00000038   E010                       LDI     R17,0
   \   0000003A   ........                   CALL    ?S_EC_MUL_L02
   \   0000003E   01FC                       MOVW    R31 : R30,R25 : R24
   \   00000040   0FE0                       ADD     R30,R16
   \   00000042   1FF1                       ADC     R31,R17
   \   00000044   2D06                       MOV     R16,R6
   \   00000046   E010                       LDI     R17,0
   \   00000048   0FE0                       ADD     R30,R16
   \   0000004A   1FF1                       ADC     R31,R17
   \   0000004C   8291                       STD     Z+1,R9
    166                  }
   \   0000004E   9463                       INC     R6
   \   00000050   CFEB                       RJMP    ??SearchBuses_2
    167              }
   \                     ??SearchBuses_3:
   \   00000052   95B3                       INC     R27
   \   00000054   CFDA                       RJMP    ??SearchBuses_0
    168              
    169              // Find the buses with slave devices.
    170              presence = OWI_DetectPresence(BUSES);
   \                     ??SearchBuses_1:
   \   00000056   E003                       LDI     R16,3
   \   00000058   ........                   CALL    OWI_DetectPresence
   \   0000005C   2EC0                       MOV     R12,R16
    171              
    172              numDevices = 0;
   \   0000005E   2477                       CLR     R7
    173              newID = devices[0].id;
   \   00000060   018C                       MOVW    R17 : R16,R25 : R24
   \   00000062   5F0F                       SUBI    R16,255
   \   00000064   4F1F                       SBCI    R17,255
   \   00000066   0128                       MOVW    R5 : R4,R17 : R16
    174              
    175              // Go through all buses with slave devices.
    176              for (currentBus = 0x01; currentBus; currentBus <<= 1)
   \   00000068   E0A1                       LDI     R26,1
   \                     ??SearchBuses_4:
   \   0000006A   23AA                       TST     R26
   \   0000006C   F189                       BREQ    ??SearchBuses_5
    177              {
    178                  lastDeviation = 0;
   \   0000006E   2488                       CLR     R8
    179                  currentID = newID;
   \   00000070   0152                       MOVW    R11 : R10,R5 : R4
    180                  if (currentBus & presence) // Devices available on this bus.
   \   00000072   2D0C                       MOV     R16,R12
   \   00000074   230A                       AND     R16,R26
   \   00000076   2300                       TST     R16
   \   00000078   F149                       BREQ    ??SearchBuses_6
    181                  {
    182                      // Do slave search on each bus, and place identifiers and corresponding
    183                      // bus "addresses" in the array.
    184                      do  
    185                      {
    186                          memcpy(newID, currentID, 8);
   \                     ??SearchBuses_7:
   \   0000007A   E048                       LDI     R20,8
   \   0000007C   E050                       LDI     R21,0
   \   0000007E   0195                       MOVW    R19 : R18,R11 : R10
   \   00000080   0182                       MOVW    R17 : R16,R5 : R4
   \   00000082   ........                   CALL    memcpy
    187                          OWI_DetectPresence(currentBus);
   \   00000086   2F0A                       MOV     R16,R26
   \   00000088   ........                   CALL    OWI_DetectPresence
    188                          lastDeviation = OWI_SearchRom(newID, lastDeviation, currentBus);
   \   0000008C   2F3A                       MOV     R19,R26
   \   0000008E   2D28                       MOV     R18,R8
   \   00000090   0182                       MOVW    R17 : R16,R5 : R4
   \   00000092   ........                   CALL    OWI_SearchRom
   \   00000096   2E80                       MOV     R8,R16
    189                          currentID = newID;
   \   00000098   0152                       MOVW    R11 : R10,R5 : R4
    190                          devices[numDevices].bus = currentBus;
   \   0000009A   2D47                       MOV     R20,R7
   \   0000009C   E050                       LDI     R21,0
   \   0000009E   E009                       LDI     R16,9
   \   000000A0   E010                       LDI     R17,0
   \   000000A2   ........                   CALL    ?S_EC_MUL_L02
   \   000000A6   01FC                       MOVW    R31 : R30,R25 : R24
   \   000000A8   0FE0                       ADD     R30,R16
   \   000000AA   1FF1                       ADC     R31,R17
   \   000000AC   83A0                       ST      Z,R26
    191                          numDevices++;
   \   000000AE   9473                       INC     R7
    192                          newID=devices[numDevices].id;                
   \   000000B0   2D47                       MOV     R20,R7
   \   000000B2   E050                       LDI     R21,0
   \   000000B4   E009                       LDI     R16,9
   \   000000B6   E010                       LDI     R17,0
   \   000000B8   ........                   CALL    ?S_EC_MUL_L02
   \   000000BC   019C                       MOVW    R19 : R18,R25 : R24
   \   000000BE   0F20                       ADD     R18,R16
   \   000000C0   1F31                       ADC     R19,R17
   \   000000C2   5F2F                       SUBI    R18,255
   \   000000C4   4F3F                       SBCI    R19,255
   \   000000C6   0129                       MOVW    R5 : R4,R19 : R18
    193                      }  while(lastDeviation != OWI_ROM_SEARCH_FINISHED);            
   \   000000C8   2088                       TST     R8
   \   000000CA   F6B9                       BRNE    ??SearchBuses_7
    194                  }
    195              }
   \                     ??SearchBuses_6:
   \   000000CC   0FAA                       LSL     R26
   \   000000CE   CFCD                       RJMP    ??SearchBuses_4
    196          
    197              // Go through all the devices and do CRC check.
    198              for (i = 0; i < numDevices; i++)
   \                     ??SearchBuses_5:
   \   000000D0   E0B0                       LDI     R27,0
   \                     ??SearchBuses_8:
   \   000000D2   15B7                       CP      R27,R7
   \   000000D4   F4A0                       BRCC    ??SearchBuses_9
    199              {
    200                  // If any id has a crc error, return error.
    201                  if(OWI_CheckRomCRC(devices[i].id) != OWI_CRC_OK)
   \   000000D6   2F4B                       MOV     R20,R27
   \   000000D8   E050                       LDI     R21,0
   \   000000DA   E009                       LDI     R16,9
   \   000000DC   E010                       LDI     R17,0
   \   000000DE   ........                   CALL    ?S_EC_MUL_L02
   \   000000E2   019C                       MOVW    R19 : R18,R25 : R24
   \   000000E4   0F20                       ADD     R18,R16
   \   000000E6   1F31                       ADC     R19,R17
   \   000000E8   5F2F                       SUBI    R18,255
   \   000000EA   4F3F                       SBCI    R19,255
   \   000000EC   0189                       MOVW    R17 : R16,R19 : R18
   \   000000EE   ........                   CALL    OWI_CheckRomCRC
   \   000000F2   2300                       TST     R16
   \   000000F4   F011                       BREQ    ??SearchBuses_10
    202                  {
    203                      return SEARCH_CRC_ERROR;
   \   000000F6   E001                       LDI     R16,1
   \   000000F8   C003                       RJMP    ??SearchBuses_11
    204                  }
    205              }
   \                     ??SearchBuses_10:
   \   000000FA   95B3                       INC     R27
   \   000000FC   CFEA                       RJMP    ??SearchBuses_8
    206              // Else, return Successful.
    207              return SEARCH_SUCCESSFUL;
   \                     ??SearchBuses_9:
   \   000000FE   E000                       LDI     R16,0
   \                     ??SearchBuses_11:
   \   00000100   E0EF                       LDI     R30,15
   \   00000102   ........                   JMP     ?EPILOGUE_B15_L09
    208          }
    209          
    210          /*! \brief  Find the first device of a family based on the family id
    211           *
    212           *  This function returns a pointer to a device in the device array
    213           *  that matches the specified family.
    214           *
    215           *  \param  familyID    The 8 bit family ID to search for.
    216           *
    217           *  \param  devices     An array of devices to search through.
    218           *
    219           *  \param  size        The size of the array 'devices'
    220           *
    221           *  \return A pointer to a device of the family.
    222           *  \retval NULL    if no device of the family was found.
    223           */

   \                                 In segment CODE, align 2, keep-with-next
    224          OWI_device * FindFamily(unsigned char familyID, OWI_device * devices, unsigned char size)
   \                     FindFamily:
    225          {
   \   00000000   2F40                       MOV     R20,R16
   \   00000002   2F61                       MOV     R22,R17
    226              unsigned char i = 0;
   \   00000004   E050                       LDI     R21,0
    227              
    228              // Search through the array.
    229              while (i < size)
   \                     ??FindFamily_0:
   \   00000006   1756                       CP      R21,R22
   \   00000008   F450                       BRCC    ??FindFamily_1
    230              {
    231                  // Return the pointer if there is a family id match.
    232                  if ((*devices).id[0] == familyID)
   \   0000000A   01F9                       MOVW    R31 : R30,R19 : R18
   \   0000000C   8101                       LDD     R16,Z+1
   \   0000000E   1704                       CP      R16,R20
   \   00000010   F411                       BRNE    ??FindFamily_2
    233                  {
    234                      return devices;
   \   00000012   0189                       MOVW    R17 : R16,R19 : R18
   \   00000014   9508                       RET
    235                  }
    236                  devices++;
   \                     ??FindFamily_2:
   \   00000016   5F27                       SUBI    R18,247
   \   00000018   4F3F                       SBCI    R19,255
    237                  i++;
   \   0000001A   9553                       INC     R21
   \   0000001C   CFF4                       RJMP    ??FindFamily_0
    238              }
    239              // Else, return NULL.
    240              return NULL;
   \                     ??FindFamily_1:
   \   0000001E   E000                       LDI     R16,0
   \   00000020   E010                       LDI     R17,0
   \   00000022   9508                       RET
    241          }
    242          
    243          
    244          /*! \brief  Read the temperature from a DS1820 temperature sensor.
    245           *
    246           *  This function will start a conversion and read back the temperature
    247           *  from a DS1820 temperature sensor.
    248           *
    249           *  \param  bus A bitmask of the bus where the DS1820 is located.
    250           *  
    251           *  \param  id  The 64 bit identifier of the DS1820.
    252           *
    253           *  \return The 16 bit signed temperature read from the DS1820.
    254           */

   \                                 In segment CODE, align 2, keep-with-next
    255          signed int DS1820_ReadTemperature(unsigned char bus, unsigned char * id)
   \                     DS1820_ReadTemperature:
    256          {
   \   00000000   ........                   CALL    ?PROLOGUE6_L09
   \   00000004                              REQUIRE ?Register_R4_is_cg_reg
   \   00000004                              REQUIRE ?Register_R5_is_cg_reg
   \   00000004   2F80                       MOV     R24,R16
   \   00000006   01D9                       MOVW    R27 : R26,R19 : R18
    257              signed int temperature;
    258              
    259              // Reset, presence.
    260              if (!OWI_DetectPresence(bus))
   \   00000008   2F08                       MOV     R16,R24
   \   0000000A   ........                   CALL    OWI_DetectPresence
   \   0000000E   2300                       TST     R16
   \   00000010   F419                       BRNE    ??DS1820_ReadTemperature_0
    261              {
    262                  return DS1820_ERROR; // Error
   \   00000012   E108                       LDI     R16,24
   \   00000014   EF1C                       LDI     R17,252
   \   00000016   C02A                       RJMP    ??DS1820_ReadTemperature_1
    263              }
    264              // Match the id found earlier.
    265              OWI_MatchRom(id, bus);
   \                     ??DS1820_ReadTemperature_0:
   \   00000018   2F28                       MOV     R18,R24
   \   0000001A   018D                       MOVW    R17 : R16,R27 : R26
   \   0000001C   ........                   CALL    OWI_MatchRom
    266              // Send start conversion command.
    267              OWI_SendByte(DS1820_START_CONVERSION, bus);
   \   00000020   2F18                       MOV     R17,R24
   \   00000022   E404                       LDI     R16,68
   \   00000024   ........                   CALL    OWI_SendByte
    268              // Wait until conversion is finished.
    269              // Bus line is held low until conversion is finished.
    270              while (!OWI_ReadBit(bus))
   \                     ??DS1820_ReadTemperature_2:
   \   00000028   2F08                       MOV     R16,R24
   \   0000002A   ........                   CALL    OWI_ReadBit
   \   0000002E   2300                       TST     R16
   \   00000030   F3D9                       BREQ    ??DS1820_ReadTemperature_2
    271              {
    272              
    273              }
    274              // Reset, presence.
    275              if(!OWI_DetectPresence(bus))
   \   00000032   2F08                       MOV     R16,R24
   \   00000034   ........                   CALL    OWI_DetectPresence
   \   00000038   2300                       TST     R16
   \   0000003A   F419                       BRNE    ??DS1820_ReadTemperature_3
    276              {
    277                  return -1000; // Error
   \   0000003C   E108                       LDI     R16,24
   \   0000003E   EF1C                       LDI     R17,252
   \   00000040   C015                       RJMP    ??DS1820_ReadTemperature_1
    278              }
    279              // Match id again.
    280              OWI_MatchRom(id, bus);
   \                     ??DS1820_ReadTemperature_3:
   \   00000042   2F28                       MOV     R18,R24
   \   00000044   018D                       MOVW    R17 : R16,R27 : R26
   \   00000046   ........                   CALL    OWI_MatchRom
    281              // Send READ SCRATCHPAD command.
    282              OWI_SendByte(DS1820_READ_SCRATCHPAD, bus);
   \   0000004A   2F18                       MOV     R17,R24
   \   0000004C   EB0E                       LDI     R16,190
   \   0000004E   ........                   CALL    OWI_SendByte
    283              // Read only two first bytes (temperature low, temperature high)
    284              // and place them in the 16 bit temperature variable.
    285              temperature = OWI_ReceiveByte(bus);
   \   00000052   2F08                       MOV     R16,R24
   \   00000054   ........                   CALL    OWI_ReceiveByte
   \   00000058   E010                       LDI     R17,0
   \   0000005A   0128                       MOVW    R5 : R4,R17 : R16
    286              temperature |= (OWI_ReceiveByte(bus) << 8);
   \   0000005C   2F08                       MOV     R16,R24
   \   0000005E   ........                   CALL    OWI_ReceiveByte
   \   00000062   2F30                       MOV     R19,R16
   \   00000064   E020                       LDI     R18,0
   \   00000066   2A42                       OR      R4,R18
   \   00000068   2A53                       OR      R5,R19
    287              
    288              return temperature;
   \   0000006A   0182                       MOVW    R17 : R16,R5 : R4
   \                     ??DS1820_ReadTemperature_1:
   \   0000006C   E0E6                       LDI     R30,6
   \   0000006E   ........                   JMP     ?EPILOGUE_B6_L09
    289          }
    290          
    291          
    292          /*! \brief  Set the wiper position of a DS2890.
    293           *
    294           *  This function initializes the DS2890 by enabling the charge pump. It then
    295           *  changes the wiper position.
    296           *
    297           *  \param  position    The new wiper position.
    298           *
    299           *  \param  bus         The bus where the DS2890 is connected.
    300           *
    301           *  \param  id          The 64 bit identifier of the DS2890.
    302           */

   \                                 In segment CODE, align 2, keep-with-next
    303          void DS2890_SetWiperPosition(unsigned char position, unsigned char bus, unsigned char * id)
   \                     DS2890_SetWiperPosition:
    304          {
   \   00000000   ........                   CALL    ?PROLOGUE4_L09
   \   00000004   2F90                       MOV     R25,R16
   \   00000006   2F81                       MOV     R24,R17
   \   00000008   01D9                       MOVW    R27 : R26,R19 : R18
    305              // Reset, presence.
    306              if(!OWI_DetectPresence(bus))
   \   0000000A   2F08                       MOV     R16,R24
   \   0000000C   ........                   CALL    OWI_DetectPresence
   \   00000010   2300                       TST     R16
   \   00000012   F1B9                       BREQ    ??DS2890_SetWiperPosition_0
    307              {
    308                  return;
    309              }
    310              //Match id.
    311              OWI_MatchRom(id, bus);
   \   00000014   2F28                       MOV     R18,R24
   \   00000016   018D                       MOVW    R17 : R16,R27 : R26
   \   00000018   ........                   CALL    OWI_MatchRom
    312              
    313              // Send Write control register command.
    314              OWI_SendByte(DS2890_WRITE_CONTROL_REGISTER, bus);
   \   0000001C   2F18                       MOV     R17,R24
   \   0000001E   E505                       LDI     R16,85
   \   00000020   ........                   CALL    OWI_SendByte
    315              
    316              // Write 0x4c to control register to enable charge pump.
    317              OWI_SendByte(0x4c, bus);
   \   00000024   2F18                       MOV     R17,R24
   \   00000026   E40C                       LDI     R16,76
   \   00000028   ........                   CALL    OWI_SendByte
    318              
    319              // Check that the value returned matches the value sent.
    320              if (OWI_ReceiveByte(bus) != 0x4c)
   \   0000002C   2F08                       MOV     R16,R24
   \   0000002E   ........                   CALL    OWI_ReceiveByte
   \   00000032   340C                       CPI     R16,76
   \   00000034   F531                       BRNE    ??DS2890_SetWiperPosition_0
    321              {
    322                  return;
    323              }
    324              
    325              // Send release code to update control register.
    326              OWI_SendByte(DS2890_RELEASE_CODE, bus);
   \   00000036   2F18                       MOV     R17,R24
   \   00000038   E906                       LDI     R16,150
   \   0000003A   ........                   CALL    OWI_SendByte
    327              
    328              // Check that zeros are returned to ensure that the operation was
    329              // successful.
    330              if (OWI_ReceiveByte(bus) == 0xff)
   \   0000003E   2F08                       MOV     R16,R24
   \   00000040   ........                   CALL    OWI_ReceiveByte
   \   00000044   3F0F                       CPI     R16,255
   \   00000046   F0E9                       BREQ    ??DS2890_SetWiperPosition_0
    331              {
    332                  return;
    333              }
    334              
    335              // Reset, presence.
    336              if (!OWI_DetectPresence(bus))
   \   00000048   2F08                       MOV     R16,R24
   \   0000004A   ........                   CALL    OWI_DetectPresence
   \   0000004E   2300                       TST     R16
   \   00000050   F0C1                       BREQ    ??DS2890_SetWiperPosition_0
    337              {
    338                  return;
    339              }
    340              
    341              // Match id.
    342              OWI_MatchRom(id, bus);
   \   00000052   2F28                       MOV     R18,R24
   \   00000054   018D                       MOVW    R17 : R16,R27 : R26
   \   00000056   ........                   CALL    OWI_MatchRom
    343              
    344              // Send the Write Position command.
    345              OWI_SendByte(DS2890_WRITE_POSITION, bus);
   \   0000005A   2F18                       MOV     R17,R24
   \   0000005C   E00F                       LDI     R16,15
   \   0000005E   ........                   CALL    OWI_SendByte
    346              
    347              // Send the new position.
    348              OWI_SendByte(position, bus);
   \   00000062   2F18                       MOV     R17,R24
   \   00000064   2F09                       MOV     R16,R25
   \   00000066   ........                   CALL    OWI_SendByte
    349              
    350              // Check that the value returned matches the value sent.
    351              if (OWI_ReceiveByte(bus) != position)
   \   0000006A   2F08                       MOV     R16,R24
   \   0000006C   ........                   CALL    OWI_ReceiveByte
   \   00000070   1709                       CP      R16,R25
   \   00000072   F439                       BRNE    ??DS2890_SetWiperPosition_0
    352              {
    353                  return;
    354              }
    355              
    356              // Send release code to update wiper position.
    357              OWI_SendByte(DS2890_RELEASE_CODE, bus);
   \   00000074   2F18                       MOV     R17,R24
   \   00000076   E906                       LDI     R16,150
   \   00000078   ........                   CALL    OWI_SendByte
    358              
    359              // Check that zeros are returned to ensure that the operation was
    360              // successful.
    361              if (OWI_ReceiveByte(bus) == 0xff)
   \   0000007C   2F08                       MOV     R16,R24
   \   0000007E   ........                   CALL    OWI_ReceiveByte
   \                     ??DS2890_SetWiperPosition_0:
   \   00000082   E0E4                       LDI     R30,4
   \   00000084   ........                   JMP     ?EPILOGUE_B4_L09
    362              {   
    363                  return;
    364              }
    365          }

   \                                 In segment ABSOLUTE, at 0x3e, root
   \   union <unnamed> volatile __io _A_EEAR
   \                     _A_EEAR:
   \   00000000                              DS 2

   \                                 In segment ABSOLUTE, at 0x40, root
   \   union <unnamed> volatile __io _A_UBRRH
   \                     _A_UBRRH:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x41, root
   \   union <unnamed> volatile __io _A_WDTCR
   \                     _A_WDTCR:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x42, root
   \   union <unnamed> volatile __io _A_ASSR
   \                     _A_ASSR:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x43, root
   \   union <unnamed> volatile __io _A_OCR2
   \                     _A_OCR2:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x44, root
   \   union <unnamed> volatile __io _A_TCNT2
   \                     _A_TCNT2:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x45, root
   \   union <unnamed> volatile __io _A_TCCR2
   \                     _A_TCCR2:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x46, root
   \   union <unnamed> volatile __io _A_ICR1
   \                     _A_ICR1:
   \   00000000                              DS 2

   \                                 In segment ABSOLUTE, at 0x48, root
   \   union <unnamed> volatile __io _A_OCR1B
   \                     _A_OCR1B:
   \   00000000                              DS 2

   \                                 In segment ABSOLUTE, at 0x4a, root
   \   union <unnamed> volatile __io _A_OCR1A
   \                     _A_OCR1A:
   \   00000000                              DS 2

   \                                 In segment ABSOLUTE, at 0x4c, root
   \   union <unnamed> volatile __io _A_TCNT1
   \                     _A_TCNT1:
   \   00000000                              DS 2

   \                                 In segment ABSOLUTE, at 0x4e, root
   \   union <unnamed> volatile __io _A_TCCR1B
   \                     _A_TCCR1B:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x4f, root
   \   union <unnamed> volatile __io _A_TCCR1A
   \                     _A_TCCR1A:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x50, root
   \   union <unnamed> volatile __io _A_SFIOR
   \                     _A_SFIOR:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x51, root
   \   union <unnamed> volatile __io _A_OSCCAL
   \                     _A_OSCCAL:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x52, root
   \   union <unnamed> volatile __io _A_TCNT0
   \                     _A_TCNT0:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x53, root
   \   union <unnamed> volatile __io _A_TCCR0
   \                     _A_TCCR0:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x54, root
   \   union <unnamed> volatile __io _A_MCUCSR
   \                     _A_MCUCSR:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x55, root
   \   union <unnamed> volatile __io _A_MCUCR
   \                     _A_MCUCR:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x56, root
   \   union <unnamed> volatile __io _A_TWCR
   \                     _A_TWCR:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x57, root
   \   union <unnamed> volatile __io _A_SPMCR
   \                     _A_SPMCR:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x58, root
   \   union <unnamed> volatile __io _A_TIFR
   \                     _A_TIFR:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x59, root
   \   union <unnamed> volatile __io _A_TIMSK
   \                     _A_TIMSK:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x5a, root
   \   union <unnamed> volatile __io _A_GIFR
   \                     _A_GIFR:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x5b, root
   \   union <unnamed> volatile __io _A_GICR
   \                     _A_GICR:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x5c, root
   \   union <unnamed> volatile __io _A_OCR0
   \                     _A_OCR0:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x5d, root
   \   union <unnamed> volatile __io _A_SP
   \                     _A_SP:
   \   00000000                              DS 2

   \                                 In segment ABSOLUTE, at 0x5f, root
   \   union <unnamed> volatile __io _A_SREG
   \                     _A_SREG:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x20, root
   \   union <unnamed> volatile __io _A_TWBR
   \                     _A_TWBR:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x21, root
   \   union <unnamed> volatile __io _A_TWSR
   \                     _A_TWSR:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x22, root
   \   union <unnamed> volatile __io _A_TWAR
   \                     _A_TWAR:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x23, root
   \   union <unnamed> volatile __io _A_TWDR
   \                     _A_TWDR:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x24, root
   \   union <unnamed> volatile __io _A_ADC
   \                     _A_ADC:
   \   00000000                              DS 2

   \                                 In segment ABSOLUTE, at 0x26, root
   \   union <unnamed> volatile __io _A_ADCSRA
   \                     _A_ADCSRA:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x27, root
   \   union <unnamed> volatile __io _A_ADMUX
   \                     _A_ADMUX:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x28, root
   \   union <unnamed> volatile __io _A_ACSR
   \                     _A_ACSR:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x29, root
   \   union <unnamed> volatile __io _A_UBRRL
   \                     _A_UBRRL:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x2a, root
   \   union <unnamed> volatile __io _A_UCSRB
   \                     _A_UCSRB:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x2b, root
   \   union <unnamed> volatile __io _A_UCSRA
   \                     _A_UCSRA:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x2c, root
   \   union <unnamed> volatile __io _A_UDR
   \                     _A_UDR:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x2d, root
   \   union <unnamed> volatile __io _A_SPCR
   \                     _A_SPCR:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x2e, root
   \   union <unnamed> volatile __io _A_SPSR
   \                     _A_SPSR:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x2f, root
   \   union <unnamed> volatile __io _A_SPDR
   \                     _A_SPDR:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x30, root
   \   union <unnamed> volatile __io _A_PIND
   \                     _A_PIND:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x31, root
   \   union <unnamed> volatile __io _A_DDRD
   \                     _A_DDRD:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x32, root
   \   union <unnamed> volatile __io _A_PORTD
   \                     _A_PORTD:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x33, root
   \   union <unnamed> volatile __io _A_PINC
   \                     _A_PINC:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x34, root
   \   union <unnamed> volatile __io _A_DDRC
   \                     _A_DDRC:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x35, root
   \   union <unnamed> volatile __io _A_PORTC
   \                     _A_PORTC:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x36, root
   \   union <unnamed> volatile __io _A_PINB
   \                     _A_PINB:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x37, root
   \   union <unnamed> volatile __io _A_DDRB
   \                     _A_DDRB:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x38, root
   \   union <unnamed> volatile __io _A_PORTB
   \                     _A_PORTB:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x39, root
   \   union <unnamed> volatile __io _A_PINA
   \                     _A_PINA:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x3a, root
   \   union <unnamed> volatile __io _A_DDRA
   \                     _A_DDRA:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x3b, root
   \   union <unnamed> volatile __io _A_PORTA
   \                     _A_PORTA:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x3c, root
   \   union <unnamed> volatile __io _A_EECR
   \                     _A_EECR:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x3d, root
   \   union <unnamed> volatile __io _A_EEDR
   \                     _A_EEDR:
   \   00000000                              DS 1

   Maximum stack usage in bytes:

     Function                     CSTACK RSTACK
     --------                     ------ ------
     DS1820_ReadTemperature           6      2
       -> OWI_DetectPresence          6      2
       -> OWI_MatchRom                6      2
       -> OWI_SendByte                6      2
       -> OWI_ReadBit                 6      2
       -> OWI_DetectPresence          6      2
       -> OWI_MatchRom                6      2
       -> OWI_SendByte                6      2
       -> OWI_ReceiveByte             6      2
       -> OWI_ReceiveByte             6      2
     DS2890_SetWiperPosition          4      2
       -> OWI_DetectPresence          4      2
       -> OWI_MatchRom                4      2
       -> OWI_SendByte                4      2
       -> OWI_SendByte                4      2
       -> OWI_ReceiveByte             4      2
       -> OWI_SendByte                4      2
       -> OWI_ReceiveByte             4      2
       -> OWI_DetectPresence          4      2
       -> OWI_MatchRom                4      2
       -> OWI_SendByte                4      2
       -> OWI_SendByte                4      2
       -> OWI_ReceiveByte             4      2
       -> OWI_SendByte                4      2
       -> OWI_ReceiveByte             4      2
     FindFamily                       0      2
     SearchBuses                     15      4
       -> OWI_DetectPresence         15      2
       -> memcpy                     15      2
       -> OWI_DetectPresence         15      2
       -> OWI_SearchRom              15      2
       -> OWI_CheckRomCRC            15      2
     main                             7      2
       -> OWI_Init                    7      2
       -> SearchBuses                 7      2
       -> FindFamily                  7      2
       -> FindFamily                  7      2
       -> DS1820_ReadTemperature      7      2
       -> DS2890_SetWiperPosition     7      2


   Segment part sizes:

     Function/Label          Bytes
     --------------          -----
     main                     110
     devices                   72
     SearchBuses              262
     FindFamily                36
     DS1820_ReadTemperature   114
     DS2890_SetWiperPosition  136
     _A_EEAR                    2
     _A_UBRRH                   1
     _A_WDTCR                   1
     _A_ASSR                    1
     _A_OCR2                    1
     _A_TCNT2                   1
     _A_TCCR2                   1
     _A_ICR1                    2
     _A_OCR1B                   2
     _A_OCR1A                   2
     _A_TCNT1                   2
     _A_TCCR1B                  1
     _A_TCCR1A                  1
     _A_SFIOR                   1
     _A_OSCCAL                  1
     _A_TCNT0                   1
     _A_TCCR0                   1
     _A_MCUCSR                  1
     _A_MCUCR                   1
     _A_TWCR                    1
     _A_SPMCR                   1
     _A_TIFR                    1
     _A_TIMSK                   1
     _A_GIFR                    1
     _A_GICR                    1
     _A_OCR0                    1
     _A_SP                      2
     _A_SREG                    1
     _A_TWBR                    1
     _A_TWSR                    1
     _A_TWAR                    1
     _A_TWDR                    1
     _A_ADC                     2
     _A_ADCSRA                  1
     _A_ADMUX                   1
     _A_ACSR                    1
     _A_UBRRL                   1
     _A_UCSRB                   1
     _A_UCSRA                   1
     _A_UDR                     1
     _A_SPCR                    1
     _A_SPSR                    1
     _A_SPDR                    1
     _A_PIND                    1
     _A_DDRD                    1
     _A_PORTD                   1
     _A_PINC                    1
     _A_DDRC                    1
     _A_PORTC                   1
     _A_PINB                    1
     _A_DDRB                    1
     _A_PORTB                   1
     _A_PINA                    1
     _A_DDRA                    1
     _A_PORTA                   1
     _A_EECR                    1
     _A_EEDR                    1
      Others                    6

 
  64 bytes in segment ABSOLUTE
 658 bytes in segment CODE
   6 bytes in segment INITTAB
  72 bytes in segment NEAR_Z
 
 658 bytes of CODE memory (+  6 bytes shared)
  72 bytes of DATA memory (+ 64 bytes shared)

Errors: none
Warnings: none
